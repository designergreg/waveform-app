<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Waveform Actionbar</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
  }

  /* Fullscreen video background */
  #bgVideo {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
    z-index: -2;
  }

  /* Actionbar container */
  .actionbar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 343px;
    height: 60px;
    border-radius: 30px;
    background: rgba(0,0,0,0.25);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 6px;
    overflow: hidden;
    z-index: 0;
  }

  /* Waveform canvas fills the actionbar */
  #wave {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
  }

  /* Icon buttons */
  .icon-button {
    width: 48px;
    height: 48px;
    border-radius: 24px;
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
    cursor: pointer;
    transition: background 0.2s;
  }

  .icon-button img {
    width: 24px;
    height: 24px;
    object-fit: contain;
    filter: brightness(0) invert(1); /* white icon */
  }

  /* Hover */
  .icon-button:hover {
    background: #1F4C7D;
  }
</style>
</head>
<body>

<video id="bgVideo" src="therapist_silent_30.mp4" autoplay loop muted playsinline></video>

<div class="actionbar">
  <!-- waveform background -->
  <canvas id="wave"></canvas>

  <!-- left pause button -->
  <div class="icon-button">
    <img src="icons/linear/pause.svg" alt="Pause">
  </div>

  <!-- right more button -->
  <div class="icon-button">
    <img src="icons/linear/more.svg" alt="More">
  </div>
</div>

<script>
const canvas = document.getElementById("wave");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
}
resize();
window.addEventListener("resize", resize);

// --- Microphone Setup ---
let smoothedRMS = 0;
let targetAmplitude = 0;

// --- Detect mobile ---
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

// --- Microphone constants ---
const BASE_AMPLITUDE = isMobile ? 20 : 12;
const MIN_WAVE = isMobile ? 15 : 10;
const RESPONSIVE_BOOST = isMobile ? 180 : 120;
const VOICE_Y_SHIFT = isMobile ? 30 : 20;

// RMS scaling for mobile sensitivity
const RMS_MULTIPLIER = isMobile ? 15 : 5;
const RMS_EXPONENT = isMobile ? 1.4 : 1.2;

async function setupMic() {
    const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });
    const audioCtx = new AudioContext();
    const source = audioCtx.createMediaStreamSource(stream);
    const analyser = audioCtx.createAnalyser();

    analyser.fftSize = 512;
    const buffer = new Uint8Array(analyser.frequencyBinCount);
    source.connect(analyser);

    function updateAudio() {
        analyser.getByteTimeDomainData(buffer);

        let sum = 0;
        for (let i = 0; i < buffer.length; i++) {
            const v = (buffer[i] - 128) / 128;
            sum += v * v;
        }
        let rawRMS = Math.sqrt(sum / buffer.length);
        if (rawRMS < 0.005) rawRMS = 0;

        const scaledRMS = Math.pow(rawRMS * RMS_MULTIPLIER, RMS_EXPONENT);

        const ATTACK = 0.8;
        const RELEASE = 0.05;
        if (scaledRMS > smoothedRMS) {
            smoothedRMS = smoothedRMS * (1 - ATTACK) + scaledRMS * ATTACK;
        } else {
            smoothedRMS = smoothedRMS * (1 - RELEASE) + scaledRMS * RELEASE;
        }

        targetAmplitude = MIN_WAVE + BASE_AMPLITUDE + smoothedRMS * RESPONSIVE_BOOST;

        requestAnimationFrame(updateAudio);
    }

    updateAudio();
}
setupMic();

// --- Perlin Noise ---
const noise = {
    grad: Array.from({length: 256}, () => Math.random() * 2 - 1),
    fade: t => t*t*t*(t*(t*6-15)+10),
    lerp: (a,b,t) => a + (b - a) * t,
    get(x) {
        const X = Math.floor(x) & 255;
        const t = x - Math.floor(x);
        const g1 = this.grad[X];
        const g2 = this.grad[X+1];
        return this.lerp(g1*t, g2*(t-1), this.fade(t));
    }
};

// --- Wave layers ---
const speed = 0.004;
const layers = [
    { color: '#5A8696', alpha: 0.6, xShift: 0 },
    { color: '#CD568A', alpha: 0.6, xShift: 80 },
    { color: '#9E6FA8', alpha: 0.6, xShift: 160 },
    { color: '#0D4CAC', alpha: 0.7, xShift: 240 }
];

let t = 0;
const peaks = 2;

// --- Fade control ---
let isTalking = false;
let fadeFactor = 0; // 0 = invisible, 1 = fully visible
const FADE_SPEED = 0.05;

// --- Input listeners ---
// Desktop spacebar
window.addEventListener("keydown", e => { if(e.code==="Space") isTalking=true; });
window.addEventListener("keyup", e => { if(e.code==="Space") isTalking=false; });

// Mobile touch anywhere
["touchstart","touchend","touchcancel"].forEach(eventName => {
    document.body.addEventListener(eventName, e => {
        e.preventDefault();
        if(eventName==="touchstart") isTalking=true;
        if(eventName==="touchend" || eventName==="touchcancel") isTalking=false;
    }, { passive: false });
});

// --- Draw single wave ---
function drawWave(layer, width, height, alphaMultiplier = 1) {
    ctx.beginPath();
    ctx.moveTo(0, height);

    const noiseScale = peaks / width;
    const dynamicOffset = smoothedRMS * VOICE_Y_SHIFT;
    const baseY = height * 0.75 - dynamicOffset;

    for (let x = 0; x < width; x++) {
        const n = noise.get((x + layer.xShift) * noiseScale + t * speed);
        const normalized = n * 0.5;
        const y = baseY - normalized * targetAmplitude;
        ctx.lineTo(x, y);
    }

    ctx.lineTo(width, height);
    ctx.closePath();

    const r = parseInt(layer.color.slice(1,3),16);
    const g = parseInt(layer.color.slice(3,5),16);
    const b = parseInt(layer.color.slice(5,7),16);
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${layer.alpha * alphaMultiplier})`;
    ctx.fill();
}

// --- Grab buttons ---
const buttons = document.querySelectorAll(".icon-button");

// --- Main Draw Loop ---
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // update fade factor
    if (isTalking) {
        fadeFactor += FADE_SPEED;
        if (fadeFactor > 1) fadeFactor = 1;
    } else {
        fadeFactor -= FADE_SPEED;
        if (fadeFactor < 0) fadeFactor = 0;
    }

    // Show/hide buttons depending on waveform visibility
    buttons.forEach(btn => {
        btn.style.display = fadeFactor > 0 ? "none" : "flex";
    });

    if (fadeFactor > 0) {
        layers.forEach(layer => drawWave(layer, canvas.width, canvas.height, fadeFactor));
    }

    t += 1;
    requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>